version: 0.2

# RagTime CodeBuild Pipeline
# Builds, tests, and deploys the RagTime CDK infrastructure stack
# Foundation CI/CD pipeline for Milestone 1

phases:
  install:
    runtime-versions:
      nodejs: 20
    commands:
      - echo "Installing dependencies..."
      - echo "Installing CDK globally..."
      - npm install -g aws-cdk@latest
      - echo "Installing GitHub CLI..."
      - curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
      - echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null
      - apt update && apt install -y gh
      - echo "Node.js version:" && node --version
      - echo "NPM version:" && npm --version
      - echo "CDK version:" && cdk --version
      - echo "GitHub CLI version:" && gh --version
      - echo "Setting CDK environment variables..."
      - export CDK_DEFAULT_ACCOUNT=$(aws sts get-caller-identity --query Account --output text)
      - export CDK_DEFAULT_REGION=$AWS_REGION
      - echo "CDK Account $CDK_DEFAULT_ACCOUNT, Region $CDK_DEFAULT_REGION"
      
  pre_build:
    commands:
      - echo "Running pre-build validations..."
      - echo "Build started on `date`"
      - echo "Current directory:" && pwd
      - echo "AWS Region:" && echo $AWS_REGION
      - echo "CodeBuild Build ID:" && echo $CODEBUILD_BUILD_ID
      
      # Validate AWS credentials
      - echo "=== CREDENTIAL VERIFICATION ==="
      - echo "AWS CLI credentials:"
      - aws sts get-caller-identity
      - echo "Testing S3 access (needed for SAM deployments):"
      - aws s3 ls || echo "S3 access test completed"
      - echo "Testing CloudFormation access:"
      - aws cloudformation list-stacks --max-items 1 || echo "CloudFormation access test completed"
      
      # Install project dependencies if any
      - |
        if [ -f "package.json" ]; then
          echo "Installing Node.js dependencies..."
          if [ -f "package-lock.json" ]; then
            npm ci
          else
            npm install
          fi
        fi
      
      # Run linting if configured
      - |
        if [ -f "package.json" ] && npm run lint --silent 2>/dev/null; then
          echo "Running lint checks..."
          npm run lint
        else
          echo "No linting configured yet - will be added in future issues"
        fi
      
      # Run tests if configured
      - |
        if [ -f "package.json" ] && npm run test --silent 2>/dev/null; then
          echo "Running test suite..."
          npm run test
        else
          echo "No tests configured yet - will be added in future issues"
        fi
      
      # Validate CDK app if it exists
      - |
        if [ -f "cdk.json" ] || [ -f "infrastructure/cdk.json" ]; then
          echo "Validating CDK application..."
          echo "Building TypeScript first..."
          npm run build
          cdk synth --quiet
        else
          echo "No CDK app found yet - this will be created in future issues"
        fi
      
  build:
    commands:
      - echo "Build phase - building CDK application..."
      - echo "CodeBuild pipeline infrastructure validated on `date`"
      
      # Build CDK app and all components
      - |
        if [ -f "package.json" ]; then
          echo "Building all components..."
          npm run build || echo "No build script configured yet"
        fi
      
      # Compile TypeScript for CDK app
      - |
        if [ -f "tsconfig.json" ] || [ -f "infrastructure/tsconfig.json" ]; then
          echo "Compiling TypeScript..."
          npx tsc || echo "TypeScript compilation will be configured in future issues"
        fi

  post_build:
    commands:
      - echo "Post-build deployment phase started..."
      - echo "Deployment started on `date`"
      
      # Set up AWS environment variables
      - echo "Setting AWS environment variables for deployment..."
      - export AWS_DEFAULT_REGION=$AWS_REGION
      - echo "AWS Region $AWS_DEFAULT_REGION"
      
      # Clear any conflicting AWS environment variables
      - unset AWS_PROFILE
      - export AWS_EC2_METADATA_DISABLED=false
      - export AWS_SDK_LOAD_CONFIG=1
      
      # Configure AWS CLI for consistent credential access
      - aws configure set default.region $AWS_DEFAULT_REGION
      - aws configure set default.output json
      
      # Fetch OpenAI API key from latest gist
      - echo "Fetching OpenAI API key from latest gist..."
      - |
        # Authenticate with GitHub using token from SSM Parameter Store
        GITHUB_TOKEN=$(aws ssm get-parameter --name /ragtime/github-token --with-decryption --query 'Parameter.Value' --output text)
        export GH_TOKEN="$GITHUB_TOKEN"
        echo "âœ… GitHub CLI authenticated"
        
        # Get the latest gist containing OpenAI API Key
        LATEST_GIST_ID=$(gh gist list --limit 1 | grep "OpenAI API Key" | awk '{print $1}')
        if [ -n "$LATEST_GIST_ID" ]; then
          echo "Found OpenAI API key gist: $LATEST_GIST_ID"
          OPENAI_API_KEY=$(gh gist view $LATEST_GIST_ID --raw | grep -v "OpenAI API Key" | tr -d '\n\r ')
          if [ -n "$OPENAI_API_KEY" ] && [[ "$OPENAI_API_KEY" == sk-* ]]; then
            export OPENAI_API_KEY="$OPENAI_API_KEY"
            echo "âœ… OpenAI API key successfully retrieved and set"
            # Mask the key in logs for security
            echo "API key starts with: ${OPENAI_API_KEY:0:10}..."
          else
            echo "âš ï¸  Could not extract valid OpenAI API key from gist"
            unset OPENAI_API_KEY
          fi
        else
          echo "âš ï¸  No OpenAI API key gist found, secret will be created with placeholder"
          unset OPENAI_API_KEY
        fi
      
      # Bootstrap CDK with conflict resolution
      - echo "Validating CDK bootstrap environment..."
      - |
        # Check if custom RagTimeCDKToolkit exists and is healthy
        CUSTOM_STACK_STATUS=$(aws cloudformation describe-stacks --stack-name RagTimeCDKToolkit --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "DOES_NOT_EXIST")
        echo "RagTimeCDKToolkit status: $CUSTOM_STACK_STATUS"
        
        # Check default CDKToolkit status
        DEFAULT_STACK_STATUS=$(aws cloudformation describe-stacks --stack-name CDKToolkit --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "DOES_NOT_EXIST")
        echo "CDKToolkit status: $DEFAULT_STACK_STATUS"
        
        # Decision logic for bootstrap approach
        if [ "$CUSTOM_STACK_STATUS" = "CREATE_COMPLETE" ] || [ "$CUSTOM_STACK_STATUS" = "UPDATE_COMPLETE" ]; then
          echo "âœ… Custom RagTimeCDKToolkit is healthy - using custom bootstrap resources"
          
          # Validate that custom toolkit provides necessary bootstrap resources
          ASSETS_BUCKET=$(aws cloudformation describe-stacks --stack-name RagTimeCDKToolkit --query 'Stacks[0].Outputs[?OutputKey==`AssetsBucketName`].OutputValue' --output text 2>/dev/null || echo "")
          if [ -z "$ASSETS_BUCKET" ]; then
            echo "âš ï¸  Custom toolkit missing assets bucket, proceeding with caution"
          else
            echo "âœ… Assets bucket found: $ASSETS_BUCKET"
          fi
          
        elif [[ "$DEFAULT_STACK_STATUS" == *"FAILED"* ]]; then
          echo "âŒ Default CDKToolkit in failed state: $DEFAULT_STACK_STATUS"
          echo "This requires manual intervention. Cannot proceed with bootstrap."
          echo "Please resolve CDKToolkit stack issues or ensure RagTimeCDKToolkit provides complete bootstrap functionality."
          exit 1
          
        elif [ "$DEFAULT_STACK_STATUS" = "DOES_NOT_EXIST" ]; then
          echo "ðŸ“¦ No default CDKToolkit found, attempting bootstrap..."
          cdk bootstrap aws://$CDK_DEFAULT_ACCOUNT/$AWS_DEFAULT_REGION --require-approval never
          
        else
          echo "âœ… Default CDKToolkit exists with status: $DEFAULT_STACK_STATUS"
          echo "Using existing CDKToolkit for bootstrap resources"
        fi
      
      # Deploy CDK stack if app exists
      - |
        if [ -f "cdk.json" ] || [ -f "infrastructure/cdk.json" ]; then
          echo "Deploying RagTime CDK stack..."
          
          # Check and handle stack state before deployment
          STACK_NAME="RagTimeInfrastructure-$DEPLOYMENT_ENVIRONMENT"
          echo "Deploying stack: $STACK_NAME"
          STACK_STATUS=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "DOES_NOT_EXIST")
          echo "Stack status: $STACK_STATUS"
          
          if [[ "$STACK_STATUS" == *"ROLLBACK"* ]]; then
            echo "Stack is in rollback state, deleting and recreating..."
            aws cloudformation delete-stack --stack-name $STACK_NAME
            echo "Waiting for stack deletion to complete..."
            aws cloudformation wait stack-delete-complete --stack-name $STACK_NAME
            echo "Stack deleted successfully"
          elif [[ "$STACK_STATUS" == *"PROGRESS"* ]]; then
            echo "Stack operation in progress, waiting for completion..."
            sleep 60
          fi
          
          # Deploy the CDK stack (includes all nested stacks automatically)
          # Note: Nested stacks are deployed automatically with the parent stack
          # Alternative: Use 'cdk deploy --all' to deploy all top-level stacks
          cdk deploy RagTimeInfrastructure-$DEPLOYMENT_ENVIRONMENT --require-approval never --verbose
          
        else
          echo "No CDK app found - deployment will be enabled when CDK app is added in issue #2"
        fi
        
        # Always verify final stack status regardless of whether CDK skipped deployment
        echo "=== FINAL STACK STATUS VALIDATION ==="
        if [ -f "cdk.json" ] || [ -f "infrastructure/cdk.json" ]; then
          STACK_NAME="RagTimeInfrastructure-$DEPLOYMENT_ENVIRONMENT"
          echo "Checking final status of stack: $STACK_NAME"
          
          FINAL_STATUS=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "DOES_NOT_EXIST")
          echo "Final stack status: $FINAL_STATUS"
          
          case "$FINAL_STATUS" in
            "CREATE_COMPLETE"|"UPDATE_COMPLETE")
              echo "âœ… Stack is in successful state: $FINAL_STATUS"
              ;;
            "ROLLBACK_COMPLETE"|"UPDATE_ROLLBACK_COMPLETE"|"CREATE_FAILED"|"UPDATE_FAILED"|"DELETE_FAILED")
              echo "âŒ Stack is in failed state: $FINAL_STATUS"
              echo "Build failing due to CloudFormation stack failure"
              exit 1
              ;;
            *"ROLLBACK"*|*"FAILED"*)
              echo "âŒ Stack is in failed state: $FINAL_STATUS"
              echo "Build failing due to CloudFormation stack failure"
              exit 1
              ;;
            "DOES_NOT_EXIST")
              echo "âš ï¸  Stack does not exist: $STACK_NAME"
              echo "Build failing because stack was not created"
              exit 1
              ;;
            *)
              echo "âš ï¸  Stack is in unexpected state: $FINAL_STATUS"
              echo "Build failing due to unexpected stack status"
              exit 1
              ;;
          esac
          
          # Verify nested stacks are also successful (only if main stack is OK)
          if [ "$FINAL_STATUS" = "CREATE_COMPLETE" ] || [ "$FINAL_STATUS" = "UPDATE_COMPLETE" ]; then
            echo "Checking nested stacks status..."
            NESTED_STACKS=$(aws cloudformation describe-stack-resources --stack-name $STACK_NAME --query 'StackResources[?ResourceType==`AWS::CloudFormation::Stack`].PhysicalResourceId' --output text)
            
            if [ -n "$NESTED_STACKS" ] && [ "$NESTED_STACKS" != "None" ]; then
              for NESTED_STACK in $NESTED_STACKS; do
                if [ "$NESTED_STACK" != "None" ] && [ -n "$NESTED_STACK" ]; then
                  NESTED_STATUS=$(aws cloudformation describe-stacks --stack-name $NESTED_STACK --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "UNKNOWN")
                  echo "Nested stack $NESTED_STACK status: $NESTED_STATUS"
                  
                  case "$NESTED_STATUS" in
                    "CREATE_COMPLETE"|"UPDATE_COMPLETE")
                      echo "âœ… Nested stack successful: $NESTED_STACK"
                      ;;
                    "ROLLBACK_COMPLETE"|"UPDATE_ROLLBACK_COMPLETE"|"CREATE_FAILED"|"UPDATE_FAILED"|"DELETE_FAILED"|*"ROLLBACK"*|*"FAILED"*)
                      echo "âŒ Nested stack failed: $NESTED_STACK ($NESTED_STATUS)"
                      echo "Build failing due to nested stack deployment failure"
                      exit 1
                      ;;
                    *)
                      echo "âš ï¸  Unknown nested stack status: $NESTED_STACK ($NESTED_STATUS)"
                      echo "Build failing due to unexpected nested stack status"
                      exit 1
                      ;;
                  esac
                fi
              done
            else
              echo "No nested stacks found or nested stacks list is empty"
            fi
          else
            echo "Skipping nested stack validation due to main stack failure"
          fi
        else
          echo "No CDK app found - skipping stack validation"
        fi
      
      # Output deployment information
      - echo "=== DEPLOYMENT SUMMARY ==="
      - echo "Environment Infrastructure Foundation"
      - echo "Region $AWS_DEFAULT_REGION"
      - echo "Build ID $CODEBUILD_BUILD_ID"
      - |
        if [ -f "cdk.json" ] || [ -f "infrastructure/cdk.json" ]; then
          STACK_NAME="RagTimeInfrastructure-$DEPLOYMENT_ENVIRONMENT"
          echo "Stack Status: $(aws cloudformation describe-stacks --stack-name $STACK_NAME --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo 'NO_STACK_YET')"
        fi
      - echo "CodeBuild pipeline deployed successfully on $(date)"

artifacts:
  files:
    - '**/*'
  name: ragtime-build-$(date +%Y-%m-%d-%H-%M-%S)
  exclude-paths:
    - 'node_modules/**/*'
    - '.git/**/*'
    - 'cdk.out/**/*'

cache:
  paths:
    - node_modules/**/*
    - ~/.npm/**/*
    - ~/.cache/pip/**/*

env:
  variables:
    NODE_ENV: production
    AWS_DEFAULT_REGION: us-east-1
  exported-variables:
    - AWS_REGION
    - AWS_DEFAULT_REGION
    - AWS_ACCOUNT_ID
    - CODEBUILD_BUILD_ID

reports:
  test_reports:
    files:
      - 'test-results.xml'
    file-format: 'JUNITXML'
    base-directory: '.'